<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title> - Data Science | ChloEvan</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="" />
<meta property="og:description" content="1. Introduction Leaflet 패키지는 동적 지도 시각화를 위한 자바스크립트-오픈소스 기반 라이브러리입니다. 일반적인 기업 회사 뿐만 아니라 GIS 전문 회사인 OpenStreetMap, Mapbox, 그리고 CartoDB에서도 이 패키지를 사용하고 있습니다.
R의 leaflet 패키지는 일종의 자바스크립트의 Leaflet을 쉽게 연동(Integrate) 할 수 있도록 도와 주는 패키지입니다.
2. Features 패키지의 주요 특징은 아래와 같습니다. 오역 방지를 위해 원문에 있는 내용을 그대로 사용했습니다.
  Interactive panning/zooming
  Compose maps using arbitrary combinations of:
 Map tiles Markers Polygons Lines Popups GeoJSON    Create maps right from the R console or RStudio" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chloevan.github.io/r/graph01_leaflet/" />


	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="1. Introduction Leaflet 패키지는 동적 지도 시각화를 위한 자바스크립트-오픈소스 기반 라이브러리입니다. 일반적인 기업 회사 뿐만 아니라 GIS 전문 회사인 OpenStreetMap, Mapbox, 그리고 CartoDB에서도 이 패키지를 사용하고 있습니다.
R의 leaflet 패키지는 일종의 자바스크립트의 Leaflet을 쉽게 연동(Integrate) 할 수 있도록 도와 주는 패키지입니다.
2. Features 패키지의 주요 특징은 아래와 같습니다. 오역 방지를 위해 원문에 있는 내용을 그대로 사용했습니다.
  Interactive panning/zooming
  Compose maps using arbitrary combinations of:
 Map tiles Markers Polygons Lines Popups GeoJSON    Create maps right from the R console or RStudio"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-160625195-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Data Science | ChloEvan" rel="home">
				<div class="logo__title">Data Science | ChloEvan</div>
				<div class="logo__tagline">Love your beloved one forever</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About ChloEvan</span>
				
			</a>
		</li>
		<li class="menu__item menu__item--active">
			<a class="menu__link" href="/r/graph01_leaflet/">
				
				<span class="menu__text">Leaflet for R</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/r/stat01_hypothesis/">
				
				<span class="menu__text">Statistics_Hypothesis</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/python/settings01_installation/">
				
				<span class="menu__text">Tensorflow 2.0 Installation</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/r/settings01_installation/">
				
				<span class="menu__text">Tensorflow 2.0 Installation - R</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title"></h1>
			<div class="post__meta meta">
<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/new-packages/" rel="category">New Packages</a>, <a class="meta__link" href="/categories/r/" rel="category">R</a>, <a class="meta__link" href="/categories/interactive-graph/" rel="category">Interactive Graph</a>, <a class="meta__link" href="/categories/data-visualization/" rel="category">Data Visualization</a>
	</span>
</div></div>
		</header>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#1-introduction">1. Introduction</a></li>
    <li><a href="#2-features">2. Features</a></li>
    <li><a href="#3-installation">3. Installation</a></li>
    <li><a href="#4-기본-사용법">4. 기본 사용법</a></li>
  </ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
			<h2 id="1-introduction">1. Introduction</h2>
<p><code>Leaflet</code> 패키지는 동적 지도 시각화를 위한 자바스크립트-오픈소스 기반 라이브러리입니다. 일반적인 기업 회사 뿐만 아니라 GIS 전문 회사인 <a href="http://www.openstreetmap.org/">OpenStreetMap</a>, <a href="http://www.mapbox.com/">Mapbox</a>, 그리고 <a href="http://cartodb.com/">CartoDB</a>에서도 이 패키지를 사용하고 있습니다.</p>
<p>R의 <code>leaflet</code> 패키지는 일종의 자바스크립트의 <code>Leaflet</code>을 쉽게 연동(Integrate) 할 수 있도록 도와 주는 패키지입니다.</p>
<h2 id="2-features">2. Features</h2>
<p>패키지의 주요 특징은 아래와 같습니다. 오역 방지를 위해 원문에 있는 내용을 그대로 사용했습니다.</p>
<ul>
<li>
<p>Interactive panning/zooming</p>
</li>
<li>
<p>Compose maps using arbitrary combinations of:</p>
<ul>
<li>Map tiles</li>
<li>Markers</li>
<li>Polygons</li>
<li>Lines</li>
<li>Popups</li>
<li>GeoJSON</li>
</ul>
</li>
<li>
<p>Create maps right from the R console or RStudio</p>
</li>
<li>
<p>Embed maps in knitr/R Markdown documents and Shiny apps</p>
<ul>
<li>R 마크다운과 Shiny Apps에 연동이 쉽게 되는 장점이 있습니다.</li>
<li>이는 보고서 작성 또는 대시보드 작성에 위 패키지를 연동할 수 있는 큰 장점이 있기 때문에 지도 분석과 관련된 업무를 하시는 분에게는 특히 강력히 추천합니다.</li>
</ul>
</li>
<li>
<p>Easily render spatial objects from the <code>sp</code> or <code>sf</code> packages, or <code>data frames</code> with <code>latitude/longitude</code> columns</p>
</li>
<li>
<p>Use map bounds and mouse events to drive <code>Shiny</code> logic</p>
</li>
<li>
<p>Display maps in non spherical mercator projections</p>
</li>
<li>
<p>Augment map features using chosen plugins from <a href="http://leafletjs.com/plugins">leaflet plugins repository</a></p>
</li>
</ul>
<h2 id="3-installation">3. Installation</h2>
<p>R 에디터 또는 콘솔창에서는 아래와 같이 입력 후 실행합니다.</p>
<pre><code>install.packages(&quot;leaflet&quot;)
# to install the development version from Github, run
# devtools::install_github(&quot;rstudio/leaflet&quot;)
</code></pre><p>이렇게 한번 설치가 된 이후에는 <a href="http://rmarkdown.rstudio.com/">R마크다운</a> 또는 <a href="http://shiny.rstudio.com/">Shiny</a>앱에서 <code>library(leaflet)</code>을 호출하여 사용할 수 있습니다.</p>
<h2 id="4-기본-사용법">4. 기본 사용법</h2>
<p>보통 아래와 같은 단계로 사용을 합니다. <a href="https://ggplot2.tidyverse.org/">ggplot2</a> 패키지를 사용하시는 분들은 데이터 + 기하함수 + 설정 등 이러한 형태로 코드를 작성한 기억을 떠올리시면 쉽게 이해가 되실 것입니다.</p>
<ul>
<li>우선 <code>leaflet()</code> 함수에 데이터프레임을 넣은 후 map 객체를 생성합니다.</li>
<li>그다음 특징에 맞춰서 layer 관련 함수를 추가합니다.
<ul>
<li>addTiles()</li>
<li>addMarkers()</li>
<li>addPolygons()</li>
</ul>
</li>
<li>각 함수들을 연결할 때에는 Pipe Operator인 R의 강력한 무기인 <code>%&gt;%</code>을 사용합니다.</li>
<li>만약에 <code>%&gt;%</code>인 익숙하지 않다면 <a href="https://github.com/smbache/magrittr">magrittr</a> 에서 구체적인 내용을 살펴봅니다.</li>
</ul>
<p>간단한 그래프를 작성합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-r" data-lang="r"><span style="color:#a6e22e">library</span>(leaflet)
<span style="color:#a6e22e">library</span>(htmlwidgets)
<span style="color:#a6e22e">library</span>(htmltools)

m <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">leaflet</span>() <span style="color:#f92672">%&gt;%</span>
  <span style="color:#a6e22e">addTiles</span>() <span style="color:#f92672">%&gt;%</span>  <span style="color:#75715e"># Add default OpenStreetMap map tiles</span>
  <span style="color:#a6e22e">addMarkers</span>(lng<span style="color:#f92672">=</span><span style="color:#ae81ff">174.768</span>, lat<span style="color:#f92672">=</span><span style="color:#ae81ff">-36.852</span>, popup<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;The birthplace of R&#34;</span>)
<span style="color:#a6e22e">saveWidget</span>(m, <span style="color:#e6db74">&#34;leafMapBasic.html&#34;</span>)

htmltools<span style="color:#f92672">::</span><span style="color:#a6e22e">includeHTML</span>(<span style="color:#e6db74">&#34;leafMapBasic.html&#34;</span>)
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>// See if we&rsquo;re running in a viewer pane. If not, we&rsquo;re in a web browser.
var viewerMode = window.HTMLWidgets.viewerMode =
/\bviewer_pane=1\b/.test(window.location);</p>
<p>// See if we&rsquo;re running in Shiny mode. If not, it&rsquo;s a static document.
// Note that static widgets can appear in both Shiny and static modes, but
// obviously, Shiny widgets can only appear in Shiny apps/documents.
var shinyMode = window.HTMLWidgets.shinyMode =
typeof(window.Shiny) !== &ldquo;undefined&rdquo; &amp;&amp; !!window.Shiny.outputBindings;</p>
<p>// We can&rsquo;t count on jQuery being available, so we implement our own
// version if necessary.
function querySelectorAll(scope, selector) {
if (typeof(jQuery) !== &ldquo;undefined&rdquo; &amp;&amp; scope instanceof jQuery) {
return scope.find(selector);
}
if (scope.querySelectorAll) {
return scope.querySelectorAll(selector);
}
}</p>
<p>function asArray(value) {
if (value === null)
return [];
if ($.isArray(value))
return value;
return [value];
}</p>
<p>// Implement jQuery&rsquo;s extend
function extend(target /*, &hellip; */) {
if (arguments.length == 1) {
return target;
}
for (var i = 1; i &lt; arguments.length; i++) {
var source = arguments[i];
for (var prop in source) {
if (source.hasOwnProperty(prop)) {
target[prop] = source[prop];
}
}
}
return target;
}</p>
<p>// IE8 doesn&rsquo;t support Array.forEach.
function forEach(values, callback, thisArg) {
if (values.forEach) {
values.forEach(callback, thisArg);
} else {
for (var i = 0; i &lt; values.length; i++) {
callback.call(thisArg, values[i], i, values);
}
}
}</p>
<p>// Replaces the specified method with the return value of funcSource.
//
// Note that funcSource should not BE the new method, it should be a function
// that RETURNS the new method. funcSource receives a single argument that is
// the overridden method, it can be called from the new method. The overridden
// method can be called like a regular function, it has the target permanently
// bound to it so &ldquo;this&rdquo; will work correctly.
function overrideMethod(target, methodName, funcSource) {
var superFunc = target[methodName] || function() {};
var superFuncBound = function() {
return superFunc.apply(target, arguments);
};
target[methodName] = funcSource(superFuncBound);
}</p>
<p>// Add a method to delegator that, when invoked, calls
// delegatee.methodName. If there is no such method on
// the delegatee, but there was one on delegator before
// delegateMethod was called, then the original version
// is invoked instead.
// For example:
//
// var a = {
//   method1: function() { console.log(&lsquo;a1&rsquo;); }
//   method2: function() { console.log(&lsquo;a2&rsquo;); }
// };
// var b = {
//   method1: function() { console.log(&lsquo;b1&rsquo;); }
// };
// delegateMethod(a, b, &ldquo;method1&rdquo;);
// delegateMethod(a, b, &ldquo;method2&rdquo;);
// a.method1();
// a.method2();
//
// The output would be &ldquo;b1&rdquo;, &ldquo;a2&rdquo;.
function delegateMethod(delegator, delegatee, methodName) {
var inherited = delegator[methodName];
delegator[methodName] = function() {
var target = delegatee;
var method = delegatee[methodName];</p>
<pre><code>  // The method doesn't exist on the delegatee. Instead,
  // call the method on the delegator, if it exists.
  if (!method) {
    target = delegator;
    method = inherited;
  }

  if (method) {
    return method.apply(target, arguments);
  }
};
</code></pre>
<p>}</p>
<p>// Implement a vague facsimilie of jQuery&rsquo;s data method
function elementData(el, name, value) {
if (arguments.length == 2) {
return el[&ldquo;htmlwidget_data_&rdquo; + name];
} else if (arguments.length == 3) {
el[&ldquo;htmlwidget_data_&rdquo; + name] = value;
return el;
} else {
throw new Error(&ldquo;Wrong number of arguments for elementData: &quot; +
arguments.length);
}
}</p>
<p>// <a href="http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex">http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex</a>
function escapeRegExp(str) {
return str.replace(/[-[]/{}()*+?.\^$|]/g, &ldquo;\$&amp;&quot;);
}</p>
<p>function hasClass(el, className) {
var re = new RegExp(&quot;\b&rdquo; + escapeRegExp(className) + &ldquo;\b&rdquo;);
return re.test(el.className);
}</p>
<p>// elements - array (or array-like object) of HTML elements
// className - class name to test for
// include - if true, only return elements with given className;
//   if false, only return elements <em>without</em> given className
function filterByClass(elements, className, include) {
var results = [];
for (var i = 0; i &lt; elements.length; i++) {
if (hasClass(elements[i], className) == include)
results.push(elements[i]);
}
return results;
}</p>
<p>function on(obj, eventName, func) {
if (obj.addEventListener) {
obj.addEventListener(eventName, func, false);
} else if (obj.attachEvent) {
obj.attachEvent(eventName, func);
}
}</p>
<p>function off(obj, eventName, func) {
if (obj.removeEventListener)
obj.removeEventListener(eventName, func, false);
else if (obj.detachEvent) {
obj.detachEvent(eventName, func);
}
}</p>
<p>// Translate array of values to top/right/bottom/left, as usual with
// the &ldquo;padding&rdquo; CSS property
// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/padding">https://developer.mozilla.org/en-US/docs/Web/CSS/padding</a>
function unpackPadding(value) {
if (typeof(value) === &ldquo;number&rdquo;)
value = [value];
if (value.length === 1) {
return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
}
if (value.length === 2) {
return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
}
if (value.length === 3) {
return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
}
if (value.length === 4) {
return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
}
}</p>
<p>// Convert an unpacked padding object to a CSS value
function paddingToCss(paddingObj) {
return paddingObj.top + &ldquo;px &quot; + paddingObj.right + &ldquo;px &quot; + paddingObj.bottom + &ldquo;px &quot; + paddingObj.left + &ldquo;px&rdquo;;
}</p>
<p>// Makes a number suitable for CSS
function px(x) {
if (typeof(x) === &ldquo;number&rdquo;)
return x + &ldquo;px&rdquo;;
else
return x;
}</p>
<p>// Retrieves runtime widget sizing information for an element.
// The return value is either null, or an object with fill, padding,
// defaultWidth, defaultHeight fields.
function sizingPolicy(el) {
var sizingEl = document.querySelector(&ldquo;script[data-for=&rsquo;&rdquo; + el.id + &ldquo;'][type='application/htmlwidget-sizing&rsquo;]&quot;);
if (!sizingEl)
return null;
var sp = JSON.parse(sizingEl.textContent || sizingEl.text || &ldquo;{}&quot;);
if (viewerMode) {
return sp.viewer;
} else {
return sp.browser;
}
}</p>
<p>// @param tasks Array of strings (or falsy value, in which case no-op).
//   Each element must be a valid JavaScript expression that yields a
//   function. Or, can be an array of objects with &ldquo;code&rdquo; and &ldquo;data&rdquo;
//   properties; in this case, the &ldquo;code&rdquo; property should be a string
//   of JS that&rsquo;s an expr that yields a function, and &ldquo;data&rdquo; should be
//   an object that will be added as an additional argument when that
//   function is called.
// @param target The object that will be &ldquo;this&rdquo; for each function
//   execution.
// @param args Array of arguments to be passed to the functions. (The
//   same arguments will be passed to all functions.)
function evalAndRun(tasks, target, args) {
if (tasks) {
forEach(tasks, function(task) {
var theseArgs = args;
if (typeof(task) === &ldquo;object&rdquo;) {
theseArgs = theseArgs.concat([task.data]);
task = task.code;
}
var taskFunc = tryEval(task);
if (typeof(taskFunc) !== &ldquo;function&rdquo;) {
throw new Error(&ldquo;Task must be a function! Source:\n&rdquo; + task);
}
taskFunc.apply(target, theseArgs);
});
}
}</p>
<p>// Attempt eval() both with and without enclosing in parentheses.
// Note that enclosing coerces a function declaration into
// an expression that eval() can parse
// (otherwise, a SyntaxError is thrown)
function tryEval(code) {
var result = null;
try {
result = eval(code);
} catch(error) {
if (!error instanceof SyntaxError) {
throw error;
}
try {
result = eval(&quot;(&rdquo; + code + &ldquo;)&quot;);
} catch(e) {
if (e instanceof SyntaxError) {
throw error;
} else {
throw e;
}
}
}
return result;
}</p>
<p>function initSizing(el) {
var sizing = sizingPolicy(el);
if (!sizing)
return;</p>
<pre><code>var cel = document.getElementById(&quot;htmlwidget_container&quot;);
if (!cel)
  return;

if (typeof(sizing.padding) !== &quot;undefined&quot;) {
  document.body.style.margin = &quot;0&quot;;
  document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
}

if (sizing.fill) {
  document.body.style.overflow = &quot;hidden&quot;;
  document.body.style.width = &quot;100%&quot;;
  document.body.style.height = &quot;100%&quot;;
  document.documentElement.style.width = &quot;100%&quot;;
  document.documentElement.style.height = &quot;100%&quot;;
  if (cel) {
    cel.style.position = &quot;absolute&quot;;
    var pad = unpackPadding(sizing.padding);
    cel.style.top = pad.top + &quot;px&quot;;
    cel.style.right = pad.right + &quot;px&quot;;
    cel.style.bottom = pad.bottom + &quot;px&quot;;
    cel.style.left = pad.left + &quot;px&quot;;
    el.style.width = &quot;100%&quot;;
    el.style.height = &quot;100%&quot;;
  }

  return {
    getWidth: function() { return cel.offsetWidth; },
    getHeight: function() { return cel.offsetHeight; }
  };

} else {
  el.style.width = px(sizing.width);
  el.style.height = px(sizing.height);

  return {
    getWidth: function() { return el.offsetWidth; },
    getHeight: function() { return el.offsetHeight; }
  };
}
</code></pre>
<p>}</p>
<p>// Default implementations for methods
var defaults = {
find: function(scope) {
return querySelectorAll(scope, &ldquo;.&rdquo; + this.name);
},
renderError: function(el, err) {
var $el = $(el);</p>
<pre><code>  this.clearError(el);

  // Add all these error classes, as Shiny does
  var errClass = &quot;shiny-output-error&quot;;
  if (err.type !== null) {
    // use the classes of the error condition as CSS class names
    errClass = errClass + &quot; &quot; + $.map(asArray(err.type), function(type) {
      return errClass + &quot;-&quot; + type;
    }).join(&quot; &quot;);
  }
  errClass = errClass + &quot; htmlwidgets-error&quot;;

  // Is el inline or block? If inline or inline-block, just display:none it
  // and add an inline error.
  var display = $el.css(&quot;display&quot;);
  $el.data(&quot;restore-display-mode&quot;, display);

  if (display === &quot;inline&quot; || display === &quot;inline-block&quot;) {
    $el.hide();
    if (err.message !== &quot;&quot;) {
      var errorSpan = $(&quot;&lt;span&gt;&quot;).addClass(errClass);
      errorSpan.text(err.message);
      $el.after(errorSpan);
    }
  } else if (display === &quot;block&quot;) {
    // If block, add an error just after the el, set visibility:none on the
    // el, and position the error to be on top of the el.
    // Mark it with a unique ID and CSS class so we can remove it later.
    $el.css(&quot;visibility&quot;, &quot;hidden&quot;);
    if (err.message !== &quot;&quot;) {
      var errorDiv = $(&quot;&lt;div&gt;&quot;).addClass(errClass).css(&quot;position&quot;, &quot;absolute&quot;)
        .css(&quot;top&quot;, el.offsetTop)
        .css(&quot;left&quot;, el.offsetLeft)
        // setting width can push out the page size, forcing otherwise
        // unnecessary scrollbars to appear and making it impossible for
        // the element to shrink; so use max-width instead
        .css(&quot;maxWidth&quot;, el.offsetWidth)
        .css(&quot;height&quot;, el.offsetHeight);
      errorDiv.text(err.message);
      $el.after(errorDiv);

      // Really dumb way to keep the size/position of the error in sync with
      // the parent element as the window is resized or whatever.
      var intId = setInterval(function() {
        if (!errorDiv[0].parentElement) {
          clearInterval(intId);
          return;
        }
        errorDiv
          .css(&quot;top&quot;, el.offsetTop)
          .css(&quot;left&quot;, el.offsetLeft)
          .css(&quot;maxWidth&quot;, el.offsetWidth)
          .css(&quot;height&quot;, el.offsetHeight);
      }, 500);
    }
  }
},
clearError: function(el) {
  var $el = $(el);
  var display = $el.data(&quot;restore-display-mode&quot;);
  $el.data(&quot;restore-display-mode&quot;, null);

  if (display === &quot;inline&quot; || display === &quot;inline-block&quot;) {
    if (display)
      $el.css(&quot;display&quot;, display);
    $(el.nextSibling).filter(&quot;.htmlwidgets-error&quot;).remove();
  } else if (display === &quot;block&quot;){
    $el.css(&quot;visibility&quot;, &quot;inherit&quot;);
    $(el.nextSibling).filter(&quot;.htmlwidgets-error&quot;).remove();
  }
},
sizing: {}
</code></pre>
<p>};</p>
<p>// Called by widget bindings to register a new type of widget. The definition
// object can contain the following properties:
// - name (required) - A string indicating the binding name, which will be
//   used by default as the CSS classname to look for.
// - initialize (optional) - A function(el) that will be called once per
//   widget element; if a value is returned, it will be passed as the third
//   value to renderValue.
// - renderValue (required) - A function(el, data, initValue) that will be
//   called with data. Static contexts will cause this to be called once per
//   element; Shiny apps will cause this to be called multiple times per
//   element, as the data changes.
window.HTMLWidgets.widget = function(definition) {
if (!definition.name) {
throw new Error(&ldquo;Widget must have a name&rdquo;);
}
if (!definition.type) {
throw new Error(&ldquo;Widget must have a type&rdquo;);
}
// Currently we only support output widgets
if (definition.type !== &ldquo;output&rdquo;) {
throw new Error(&ldquo;Unrecognized widget type &lsquo;&rdquo; + definition.type + &ldquo;'&quot;);
}
// TODO: Verify that .name is a valid CSS classname</p>
<pre><code>// Support new-style instance-bound definitions. Old-style class-bound
// definitions have one widget &quot;object&quot; per widget per type/class of
// widget; the renderValue and resize methods on such widget objects
// take el and instance arguments, because the widget object can't
// store them. New-style instance-bound definitions have one widget
// object per widget instance; the definition that's passed in doesn't
// provide renderValue or resize methods at all, just the single method
//   factory(el, width, height)
// which returns an object that has renderValue(x) and resize(w, h).
// This enables a far more natural programming style for the widget
// author, who can store per-instance state using either OO-style
// instance fields or functional-style closure variables (I guess this
// is in contrast to what can only be called C-style pseudo-OO which is
// what we required before).
if (definition.factory) {
  definition = createLegacyDefinitionAdapter(definition);
}

if (!definition.renderValue) {
  throw new Error(&quot;Widget must have a renderValue function&quot;);
}

// For static rendering (non-Shiny), use a simple widget registration
// scheme. We also use this scheme for Shiny apps/documents that also
// contain static widgets.
window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
// Merge defaults into the definition; don't mutate the original definition.
var staticBinding = extend({}, defaults, definition);
overrideMethod(staticBinding, &quot;find&quot;, function(superfunc) {
  return function(scope) {
    var results = superfunc(scope);
    // Filter out Shiny outputs, we only want the static kind
    return filterByClass(results, &quot;html-widget-output&quot;, false);
  };
});
window.HTMLWidgets.widgets.push(staticBinding);

if (shinyMode) {
  // Shiny is running. Register the definition with an output binding.
  // The definition itself will not be the output binding, instead
  // we will make an output binding object that delegates to the
  // definition. This is because we foolishly used the same method
  // name (renderValue) for htmlwidgets definition and Shiny bindings
  // but they actually have quite different semantics (the Shiny
  // bindings receive data that includes lots of metadata that it
  // strips off before calling htmlwidgets renderValue). We can't
  // just ignore the difference because in some widgets it's helpful
  // to call this.renderValue() from inside of resize(), and if
  // we're not delegating, then that call will go to the Shiny
  // version instead of the htmlwidgets version.

  // Merge defaults with definition, without mutating either.
  var bindingDef = extend({}, defaults, definition);

  // This object will be our actual Shiny binding.
  var shinyBinding = new Shiny.OutputBinding();

  // With a few exceptions, we'll want to simply use the bindingDef's
  // version of methods if they are available, otherwise fall back to
  // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
  // methods in the future, and we want them to be overrideable by
  // HTMLWidget binding definitions, then we'll need to add them to this
  // list.
  delegateMethod(shinyBinding, bindingDef, &quot;getId&quot;);
  delegateMethod(shinyBinding, bindingDef, &quot;onValueChange&quot;);
  delegateMethod(shinyBinding, bindingDef, &quot;onValueError&quot;);
  delegateMethod(shinyBinding, bindingDef, &quot;renderError&quot;);
  delegateMethod(shinyBinding, bindingDef, &quot;clearError&quot;);
  delegateMethod(shinyBinding, bindingDef, &quot;showProgress&quot;);

  // The find, renderValue, and resize are handled differently, because we
  // want to actually decorate the behavior of the bindingDef methods.

  shinyBinding.find = function(scope) {
    var results = bindingDef.find(scope);

    // Only return elements that are Shiny outputs, not static ones
    var dynamicResults = results.filter(&quot;.html-widget-output&quot;);

    // It's possible that whatever caused Shiny to think there might be
    // new dynamic outputs, also caused there to be new static outputs.
    // Since there might be lots of different htmlwidgets bindings, we
    // schedule execution for later--no need to staticRender multiple
    // times.
    if (results.length !== dynamicResults.length)
      scheduleStaticRender();

    return dynamicResults;
  };

  // Wrap renderValue to handle initialization, which unfortunately isn't
  // supported natively by Shiny at the time of this writing.

  shinyBinding.renderValue = function(el, data) {
    Shiny.renderDependencies(data.deps);
    // Resolve strings marked as javascript literals to objects
    if (!(data.evals instanceof Array)) data.evals = [data.evals];
    for (var i = 0; data.evals &amp;&amp; i &lt; data.evals.length; i++) {
      window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
    }
    if (!bindingDef.renderOnNullValue) {
      if (data.x === null) {
        el.style.visibility = &quot;hidden&quot;;
        return;
      } else {
        el.style.visibility = &quot;inherit&quot;;
      }
    }
    if (!elementData(el, &quot;initialized&quot;)) {
      initSizing(el);

      elementData(el, &quot;initialized&quot;, true);
      if (bindingDef.initialize) {
        var result = bindingDef.initialize(el, el.offsetWidth,
          el.offsetHeight);
        elementData(el, &quot;init_result&quot;, result);
      }
    }
    bindingDef.renderValue(el, data.x, elementData(el, &quot;init_result&quot;));
    evalAndRun(data.jsHooks.render, elementData(el, &quot;init_result&quot;), [el, data.x]);
  };

  // Only override resize if bindingDef implements it
  if (bindingDef.resize) {
    shinyBinding.resize = function(el, width, height) {
      // Shiny can call resize before initialize/renderValue have been
      // called, which doesn't make sense for widgets.
      if (elementData(el, &quot;initialized&quot;)) {
        bindingDef.resize(el, width, height, elementData(el, &quot;init_result&quot;));
      }
    };
  }

  Shiny.outputBindings.register(shinyBinding, bindingDef.name);
}
</code></pre>
<p>};</p>
<p>var scheduleStaticRenderTimerId = null;
function scheduleStaticRender() {
if (!scheduleStaticRenderTimerId) {
scheduleStaticRenderTimerId = setTimeout(function() {
scheduleStaticRenderTimerId = null;
window.HTMLWidgets.staticRender();
}, 1);
}
}</p>
<p>// Render static widgets after the document finishes loading
// Statically render all elements that are of this widget&rsquo;s class
window.HTMLWidgets.staticRender = function() {
var bindings = window.HTMLWidgets.widgets || [];
forEach(bindings, function(binding) {
var matches = binding.find(document.documentElement);
forEach(matches, function(el) {
var sizeObj = initSizing(el, binding);</p>
<pre><code>    if (hasClass(el, &quot;html-widget-static-bound&quot;))
      return;
    el.className = el.className + &quot; html-widget-static-bound&quot;;

    var initResult;
    if (binding.initialize) {
      initResult = binding.initialize(el,
        sizeObj ? sizeObj.getWidth() : el.offsetWidth,
        sizeObj ? sizeObj.getHeight() : el.offsetHeight
      );
      elementData(el, &quot;init_result&quot;, initResult);
    }

    if (binding.resize) {
      var lastSize = {
        w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
        h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
      };
      var resizeHandler = function(e) {
        var size = {
          w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
          h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
        };
        if (size.w === 0 &amp;&amp; size.h === 0)
          return;
        if (size.w === lastSize.w &amp;&amp; size.h === lastSize.h)
          return;
        lastSize = size;
        binding.resize(el, size.w, size.h, initResult);
      };

      on(window, &quot;resize&quot;, resizeHandler);

      // This is needed for cases where we're running in a Shiny
      // app, but the widget itself is not a Shiny output, but
      // rather a simple static widget. One example of this is
      // an rmarkdown document that has runtime:shiny and widget
      // that isn't in a render function. Shiny only knows to
      // call resize handlers for Shiny outputs, not for static
      // widgets, so we do it ourselves.
      if (window.jQuery) {
        window.jQuery(document).on(
          &quot;shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets&quot;,
          resizeHandler
        );
        window.jQuery(document).on(
          &quot;hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets&quot;,
          resizeHandler
        );
      }

      // This is needed for the specific case of ioslides, which
      // flips slides between display:none and display:block.
      // Ideally we would not have to have ioslide-specific code
      // here, but rather have ioslides raise a generic event,
      // but the rmarkdown package just went to CRAN so the
      // window to getting that fixed may be long.
      if (window.addEventListener) {
        // It's OK to limit this to window.addEventListener
        // browsers because ioslides itself only supports
        // such browsers.
        on(document, &quot;slideenter&quot;, resizeHandler);
        on(document, &quot;slideleave&quot;, resizeHandler);
      }
    }

    var scriptData = document.querySelector(&quot;script[data-for='&quot; + el.id + &quot;'][type='application/json']&quot;);
    if (scriptData) {
      var data = JSON.parse(scriptData.textContent || scriptData.text);
      // Resolve strings marked as javascript literals to objects
      if (!(data.evals instanceof Array)) data.evals = [data.evals];
      for (var k = 0; data.evals &amp;&amp; k &lt; data.evals.length; k++) {
        window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
      }
      binding.renderValue(el, data.x, initResult);
      evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
    }
  });
});

invokePostRenderHandlers();
</code></pre>
<p>}</p>
<p>function has_jQuery3() {
if (!window.jQuery) {
return false;
}
var $version = window.jQuery.fn.jquery;
var $major_version = parseInt($version.split(&quot;.&quot;)[0]);
return $major_version &gt;= 3;
}</p>
<p>/*
/ Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery&rsquo;s
/ on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
/ really means $(setTimeout(fn)).
/ <a href="https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous">https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous</a>
/
/ Since Shiny uses $() to schedule initShiny, shiny&gt;=1.4 calls initShiny
/ one tick later than it did before, which means staticRender() is
/ called renderValue() earlier than (advanced) widget authors might be expecting.
/ <a href="https://github.com/rstudio/shiny/issues/2630">https://github.com/rstudio/shiny/issues/2630</a>
/
/ For a concrete example, leaflet has some methods (e.g., updateBounds)
/ which reference Shiny methods registered in initShiny (e.g., setInputValue).
/ Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
/ delay execution of those methods (until Shiny methods are ready)
/ <a href="https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268">https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268</a>
/
/ Ideally widget authors wouldn&rsquo;t need to use this setTimeout() hack that
/ leaflet uses to call Shiny methods on a staticRender(). In the long run,
/ the logic initShiny should be broken up so that method registration happens
/ right away, but binding happens later.
*/
function maybeStaticRenderLater() {
if (shinyMode &amp;&amp; has_jQuery3()) {
window.jQuery(window.HTMLWidgets.staticRender);
} else {
window.HTMLWidgets.staticRender();
}
}</p>
<p>if (document.addEventListener) {
document.addEventListener(&ldquo;DOMContentLoaded&rdquo;, function() {
document.removeEventListener(&ldquo;DOMContentLoaded&rdquo;, arguments.callee, false);
maybeStaticRenderLater();
}, false);
} else if (document.attachEvent) {
document.attachEvent(&ldquo;onreadystatechange&rdquo;, function() {
if (document.readyState === &ldquo;complete&rdquo;) {
document.detachEvent(&ldquo;onreadystatechange&rdquo;, arguments.callee);
maybeStaticRenderLater();
}
});
}</p>
<p>window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
// If no key, default to the first item
if (typeof(key) === &ldquo;undefined&rdquo;)
key = 1;</p>
<pre><code>var link = document.getElementById(depname + &quot;-&quot; + key + &quot;-attachment&quot;);
if (!link) {
  throw new Error(&quot;Attachment &quot; + depname + &quot;/&quot; + key + &quot; not found in document&quot;);
}
return link.getAttribute(&quot;href&quot;);
</code></pre>
<p>};</p>
<p>window.HTMLWidgets.dataframeToD3 = function(df) {
var names = [];
var length;
for (var name in df) {
if (df.hasOwnProperty(name))
names.push(name);
if (typeof(df[name]) !== &ldquo;object&rdquo; || typeof(df[name].length) === &ldquo;undefined&rdquo;) {
throw new Error(&ldquo;All fields must be arrays&rdquo;);
} else if (typeof(length) !== &ldquo;undefined&rdquo; &amp;&amp; length !== df[name].length) {
throw new Error(&ldquo;All fields must be arrays of the same length&rdquo;);
}
length = df[name].length;
}
var results = [];
var item;
for (var row = 0; row &lt; length; row++) {
item = {};
for (var col = 0; col &lt; names.length; col++) {
item[names[col]] = df[names[col]][row];
}
results.push(item);
}
return results;
};</p>
<p>window.HTMLWidgets.transposeArray2D = function(array) {
if (array.length === 0) return array;
var newArray = array[0].map(function(col, i) {
return array.map(function(row) {
return row[i]
})
});
return newArray;
};
// Split value at splitChar, but allow splitChar to be escaped
// using escapeChar. Any other characters escaped by escapeChar
// will be included as usual (including escapeChar itself).
function splitWithEscape(value, splitChar, escapeChar) {
var results = [];
var escapeMode = false;
var currentResult = &ldquo;&quot;;
for (var pos = 0; pos &lt; value.length; pos++) {
if (!escapeMode) {
if (value[pos] === splitChar) {
results.push(currentResult);
currentResult = &ldquo;&quot;;
} else if (value[pos] === escapeChar) {
escapeMode = true;
} else {
currentResult += value[pos];
}
} else {
currentResult += value[pos];
escapeMode = false;
}
}
if (currentResult !== &ldquo;&quot;) {
results.push(currentResult);
}
return results;
}
// Function authored by Yihui/JJ Allaire
window.HTMLWidgets.evaluateStringMember = function(o, member) {
var parts = splitWithEscape(member, &lsquo;.', &lsquo;\');
for (var i = 0, l = parts.length; i &lt; l; i++) {
var part = parts[i];
// part may be a character or &lsquo;numeric&rsquo; member name
if (o !== null &amp;&amp; typeof o === &ldquo;object&rdquo; &amp;&amp; part in o) {
if (i == (l - 1)) { // if we are at the end of the line then evalulate
if (typeof o[part] === &ldquo;string&rdquo;)
o[part] = tryEval(o[part]);
} else { // otherwise continue to next embedded object
o = o[part];
}
}
}
};</p>
<p>// Retrieve the HTMLWidget instance (i.e. the return value of an
// HTMLWidget binding&rsquo;s initialize() or factory() function)
// associated with an element, or null if none.
window.HTMLWidgets.getInstance = function(el) {
return elementData(el, &ldquo;init_result&rdquo;);
};</p>
<p>// Finds the first element in the scope that matches the selector,
// and returns the HTMLWidget instance (i.e. the return value of
// an HTMLWidget binding&rsquo;s initialize() or factory() function)
// associated with that element, if any. If no element matches the
// selector, or the first matching element has no HTMLWidget
// instance associated with it, then null is returned.
//
// The scope argument is optional, and defaults to window.document.
window.HTMLWidgets.find = function(scope, selector) {
if (arguments.length == 1) {
selector = scope;
scope = document;
}</p>
<pre><code>var el = scope.querySelector(selector);
if (el === null) {
  return null;
} else {
  return window.HTMLWidgets.getInstance(el);
}
</code></pre>
<p>};</p>
<p>// Finds all elements in the scope that match the selector, and
// returns the HTMLWidget instances (i.e. the return values of
// an HTMLWidget binding&rsquo;s initialize() or factory() function)
// associated with the elements, in an array. If elements that
// match the selector don&rsquo;t have an associated HTMLWidget
// instance, the returned array will contain nulls.
//
// The scope argument is optional, and defaults to window.document.
window.HTMLWidgets.findAll = function(scope, selector) {
if (arguments.length == 1) {
selector = scope;
scope = document;
}</p>
<pre><code>var nodes = scope.querySelectorAll(selector);
var results = [];
for (var i = 0; i &lt; nodes.length; i++) {
  results.push(window.HTMLWidgets.getInstance(nodes[i]));
}
return results;
</code></pre>
<p>};</p>
<p>var postRenderHandlers = [];
function invokePostRenderHandlers() {
while (postRenderHandlers.length) {
var handler = postRenderHandlers.shift();
if (handler) {
handler();
}
}
}</p>
<p>// Register the given callback function to be invoked after the
// next time static widgets are rendered.
window.HTMLWidgets.addPostRenderHandler = function(callback) {
postRenderHandlers.push(callback);
};</p>
<p>// Takes a new-style instance-bound definition, and returns an
// old-style class-bound definition. This saves us from having
// to rewrite all the logic in this file to accomodate both
// types of definitions.
function createLegacyDefinitionAdapter(defn) {
var result = {
name: defn.name,
type: defn.type,
initialize: function(el, width, height) {
return defn.factory(el, width, height);
},
renderValue: function(el, x, instance) {
return instance.renderValue(x);
},
resize: function(el, width, height, instance) {
return instance.resize(width, height);
}
};</p>
<pre><code>if (defn.find)
  result.find = defn.find;
if (defn.renderError)
  result.renderError = defn.renderError;
if (defn.clearError)
  result.clearError = defn.clearError;

return result;
</code></pre>
<p>}
})();</p>
<p><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item"><a class="tags__link btn" href="/tags/development/" rel="tag">Development</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/r/" rel="tag">R</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/python/" rel="tag">Python</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/leaflet/" rel="tag">leaflet</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/data-visualization/" rel="tag">Data Visualization</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/interactive-graph/" rel="tag">Interactive Graph</a></li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ChloEvan avatar" src="/img/couple.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About ChloEvan</span>
	</div>
	<div class="authorbox__description">
		ChloEvan is just one who is loving Chloe and analyzing Data things
	</div>
</div>

<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/r/stat01_hypothesis/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">Stat01_hypothesis</p></a>
	</div>
</nav>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<label>
			<input class="widget-search__field" type="search" placeholder="SEARCH..." value="" name="q" aria-label="SEARCH...">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="https://chloevan.github.io/" />
	</form>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/r/settings01_installation/">Tensorflow For R - Quick Start</a></li>
			<li class="widget__item"><a class="widget__link" href="/python/settings01_installation/">Tensorflow 2.0 Installation</a></li>
			<li class="widget__item"><a class="widget__link" href="/r/stat01_hypothesis/">Stat01_hypothesis</a></li>
			<li class="widget__item"><a class="widget__link" href="/r/graph01_leaflet/"></a></li>
		</ul>
	</div>
</div>
<div class="widget-categories widget">
	<h4 class="widget__title">Categories</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item">
				<a class="widget__link" href="/categories/data-visualization/">Data Visualization</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/development/">Development</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/interactive-graph/">Interactive Graph</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/new-packages/">New Packages</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/python/">Python</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/r/">R</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/statistics/">Statistics</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/tensorflow-2.0/">Tensorflow 2.0</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/%EA%B8%B0%EC%B4%88%ED%86%B5%EA%B3%84/">기초통계</a>
			</li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/data-visualization/" title="Data Visualization">Data Visualization</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/development/" title="Development">Development</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/interactive-graph/" title="Interactive Graph">Interactive Graph</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/jupyter-notebook/" title="Jupyter Notebook">Jupyter Notebook</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/leaflet/" title="leaflet">leaflet</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/python/" title="Python">Python</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/r/" title="R">R</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/statistics/" title="Statistics">Statistics</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tensorflow-2.0/" title="Tensorflow 2.0">Tensorflow 2.0</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tensorflow-for-r/" title="Tensorflow for R">Tensorflow for R</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%EA%B8%B0%EC%B4%88%ED%86%B5%EA%B3%84/" title="기초통계">기초통계</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 ChloEvan.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>